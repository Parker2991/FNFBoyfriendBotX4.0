'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InstructionFactory = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _Opcodes = require('./Opcodes');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Factory class for creating an instruction by its opcode and instruction
 * index inside a Code attribute.
 */
var InstructionFactory = exports.InstructionFactory = function () {
  /**
   * @private
   * @param  {MethodInfo} methodInfo The method the given instruction is in
   * @param  {Number} idx            instruction index
   * @param  {Number} opcode         opcode identifier
   * @param  {Boolean} wide          wide instruction flag
   */
  function InstructionFactory(methodInfo, idx, opcode, wide) {
    _classCallCheck(this, InstructionFactory);

    /**
     * @private
     * @type {MethodInfo}
     */
    this.methodInfo = methodInfo;
    /**
     * @private
     * @type {Number}
     */
    this.idx = idx;
    /**
     * @private
     * @type {Number}
     */
    this.opcode = opcode;
    /**
     * @private
     * @type {Boolean}
     */
    this.wide = wide;
    /**
     * @private
     * @type {AbstractInstruction}
     */
    this.instruction = (0, _Opcodes.getInstructionType)(opcode);
  }

  /**
   * Flag for if the instruction is wide.
   * @private
   * @return {Boolean}
   */


  _createClass(InstructionFactory, [{
    key: 'build',


    /**
     * Creates an instance of the instruction and wraps it with an
     * {@link InstructionWrapper} if necessary.
     * @private
     * @return {AbstractInstruction}
     */
    value: function build() {
      var instance = this.createInstance();

      if (this.shouldWrap) {
        instance = new this.wrapType(instance);
      }

      return instance;
    }

    /**
     * @private
     * @return {AbstractInstruction}
     */

  }, {
    key: 'createInstance',
    value: function createInstance() {
      var InsnType = this.instruction.type;

      return this.isWide ? new InsnType(this.methodInfo, this.idx, this.opcode, this.wide) : new InsnType(this.methodInfo, this.idx, this.opcode);
    }

    /**
     * Creates instructions based on pre-defined configurations allowing the
     * complex process of building instructions to be simplified into a 3
     * parameter method.
     * @public
     * @param  {MethodInfo} methodInfo The method the given instruction is in
     * @param  {Number} idx            instruction index
     * @param  {Number} opcode opcode  identifier
     * @param  {Boolean} wide          wide instruction flag
     * @return {AbstractInstruction}
     */

  }, {
    key: 'isWide',
    get: function get() {
      return this.instruction.subject_to_wide;
    }

    /**
     * Flag for if the instruction should be wrapped by an {@link InstructionWrapper}
     * object.
     * @private
     * @return {Boolean}
     */

  }, {
    key: 'shouldWrap',
    get: function get() {
      return this.wrapType !== null;
    }

    /**
     * Gets the type of wrapper that should be applied when creating the instruction.
     * @private
     * @return {InstructionWrapper|null}
     */

  }, {
    key: 'wrapType',
    get: function get() {
      return this.instruction.wrap || null;
    }
  }], [{
    key: 'of',
    value: function of(methodInfo, idx, opcode, wide) {
      return new InstructionFactory(methodInfo, idx, opcode, wide).build();
    }
  }]);

  return InstructionFactory;
}();