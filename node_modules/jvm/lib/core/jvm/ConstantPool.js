'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConstantPool = exports.NUMERIC_TAGS = exports.TAG_INVOKE_DYNAMIC = exports.TAG_METHOD_TYPE = exports.TAG_METHOD_HANDLE = exports.TAG_UTF8 = exports.TAG_NAME_AND_TYPE = exports.TAG_DOUBLE = exports.TAG_LONG = exports.TAG_FLOAT = exports.TAG_INTEGER = exports.TAG_STRING = exports.TAG_INTERFACE_METHOD_REF = exports.TAG_METHOD_REF = exports.TAG_FIELD_REF = exports.TAG_CLASS = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TAG_CLASS = exports.TAG_CLASS = 7;
var TAG_FIELD_REF = exports.TAG_FIELD_REF = 9;
var TAG_METHOD_REF = exports.TAG_METHOD_REF = 10;
var TAG_INTERFACE_METHOD_REF = exports.TAG_INTERFACE_METHOD_REF = 11;
var TAG_STRING = exports.TAG_STRING = 8;
var TAG_INTEGER = exports.TAG_INTEGER = 3;
var TAG_FLOAT = exports.TAG_FLOAT = 4;
var TAG_LONG = exports.TAG_LONG = 5;
var TAG_DOUBLE = exports.TAG_DOUBLE = 6;
var TAG_NAME_AND_TYPE = exports.TAG_NAME_AND_TYPE = 12;
var TAG_UTF8 = exports.TAG_UTF8 = 1;
var TAG_METHOD_HANDLE = exports.TAG_METHOD_HANDLE = 15;
var TAG_METHOD_TYPE = exports.TAG_METHOD_TYPE = 16;
var TAG_INVOKE_DYNAMIC = exports.TAG_INVOKE_DYNAMIC = 18;

var NUMERIC_TAGS = exports.NUMERIC_TAGS = [TAG_INTEGER, TAG_DOUBLE, TAG_FLOAT, TAG_LONG];

var L_POSITIVE_INFINITY = 0x7ff0000000000000;
var L_NEGATIVE_INFINITY = 0xfff0000000000000;
var F_POSITIVE_INFINITY = 0x7f800000;
var F_NEGATIVE_INFINITY = 0xff800000;

/**
 * Wrapper around the JVM Class File's Constant Pool table.
 *
 * It provides simplified access to the elements contained in the Constant
 * Pool while.
 *
 * @see https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4
 */

var ConstantPool = function () {
  /**
   * @param  {Array<Object>} pool
   */
  function ConstantPool(pool) {
    _classCallCheck(this, ConstantPool);

    /** @type {{Array<Object>} pool} */
    this.pool = pool;
  }

  /**
   * The 1-based index into the Constant Pool for which you wish to retrieve
   * the entry from.
   * 
   * Indices MUST be: `1 ≤ index ≤ ConstantPool#size`
   * 
   * @see https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.5
   * @param  {Number} idx
   * @return {Object|false} - returns false if the index passed is the second
   * half (empty) of a Double or Long entry in the Constant Pool. See the
   * Oracle link below for more information.
   */


  _createClass(ConstantPool, [{
    key: 'at',
    value: function at(idx) {
      return this.pool[idx - 1];
    }

    /**
     * Decodes the entry's value at the Constant Pool index specified.
     * @param  {Number} idx - index of the entry to decode.
     * @return {Number|string|undefined} returns undefined if the entry was not able to be decoded.
     */

  }, {
    key: 'valueAt',
    value: function valueAt(idx) {
      var entry = this.at(idx);

      switch (entry.tag) {
        case TAG_STRING:
          return this.at(entry.info.string_index).info.bytes;
        case TAG_INTEGER:
          return entry.info.value;
        case TAG_LONG:
          {
            var low = entry.info.low_bytes;
            var high = entry.info.high_bytes;
            return (high << 32) + low;
          }
        case TAG_FLOAT:
          {
            var bits = entry.value;

            if (bits === F_POSITIVE_INFINITY) {
              return Number.POSITIVE_INFINITY;
            } else if (bits === F_NEGATIVE_INFINITY) {
              return Number.NEGATIVE_INFINITY;
            }

            if (bits > F_POSITIVE_INFINITY && bits <= 0x7fffffff || bits > F_NEGATIVE_INFINITY && bits <= 0xffffffff) {
              return NaN;
            }

            var sign = bits >> 31 === 0 ? 1 : -1;
            var exponent = bits >> 23 & 0xff;
            var mantisa = exponent === 0 ? (bits & 0x7fffff) << 1 : bits & 0x7fffff | 0x800000;

            return sign * mantisa * Math.pow(2, exponent - 150);
          }
        case TAG_DOUBLE:
          {
            var _low = entry.info.low_bytes;
            var _high = entry.info.high_bytes;
            var _bits = (_high << 32) + _low;

            if (_bits === L_POSITIVE_INFINITY) {
              return Number.POSITIVE_INFINITY;
            } else if (_bits === L_NEGATIVE_INFINITY) {
              return Number.NEGATIVE_INFINITY;
            }

            if (_bits > L_POSITIVE_INFINITY && _bits <= 0x7fffffffffffffff || _bits > L_NEGATIVE_INFINITY && _bits <= 0xffffffffffffffff) {
              return NaN;
            }

            var _sign = _bits >> 63 === 0 ? 1 : -1;
            var _exponent = _bits >> 52 & 0x7ff;
            var _mantisa = _exponent === 0 ? (_bits & 0xfffffffffffff) << 1 : _bits & 0xfffffffffffff | 0x10000000000000;

            return _sign * _mantisa * Math.pow(2, _exponent - 1075);
          }
        case TAG_CLASS:
          return this.at(entry.info.name_index).info.bytes;
      }
    }

    /**
     * Attempts to find the first entry in the pool matching the specified
     * criteria going from the first index to the last.
     * @see https://lodash.com/docs#find
     * @see https://lodash.com/docs#matches
     * @param  {Object} criteria Search criteria
     * @return {Object|undefined} returns {@link undefined} if no match could be found
     */

  }, {
    key: 'find',
    value: function find(criteria) {
      return _.find(this.pool, criteria);
    }

    /**
     * The total size of the Constant Pool.
     * @return {Number}
     */

  }, {
    key: 'toObject',


    /**
     * Serialized version of this class without circular references.
     * @return {Object}
     */
    value: function toObject() {
      return {
        constant_pool_count: this.size,
        entries: this.pool
      };
    }
  }, {
    key: 'size',
    get: function get() {
      return _.size(this.pool);
    }
  }]);

  return ConstantPool;
}();

exports.ConstantPool = ConstantPool;