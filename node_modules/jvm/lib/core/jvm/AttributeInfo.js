'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AttributeInfo = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _AccessFlags = require('./AccessFlags');

var _BytecodeInstructions = require('../parsers/BytecodeInstructions');

var _Attributes = require('./Attributes');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AttributeDecoderLookup = {
  Code: function Code(method) {
    if (method.hasNoMethodBody) {
      throw new Error('This method has no method body.');
    }

    return (0, _BytecodeInstructions.parseInstructions)(method);
  },
  ConstantValue: function ConstantValue(field) {
    var attr = _.find(field.attributes, { name: 'ConstantValue' }).raw;
    var idx = new _Attributes.AttributeMapping.ConstantValue(attr).decode();

    return field.classInfo.pool.valueAt(idx);
  }
};

/**
 * Wraps JVM Class File Attributes for Classes, Methods and Fields.
 */

var AttributeInfo = function () {
  /**
   * @param  {Object} attr - raw attribute data
   * @param  {MemberInfo} owner - the owning object of this attribute
   */
  function AttributeInfo(attr, owner) {
    _classCallCheck(this, AttributeInfo);

    /** @type {Object} */
    this._attr = attr;
    /** @type {Buffer} */
    this._data = attr.info;
    /** @type {Boolean} */
    this._decoded = false;
    /** @type {string} */
    this._name = attr.attribute_name;
    /** @type {MemberInfo} */
    this._owner = owner;
  }

  /**
   * Attempts to decode the attribute against a lookup table of supported
   * attribute parsers. This should work on all well-formed, attributes
   * supported by the Java SE runtimes.
   * @return {Object}
   */


  _createClass(AttributeInfo, [{
    key: 'toObject',


    /**
     * Serialized version of this class without circular references.
     * @return {Object}
     */
    value: function toObject() {
      return {
        name: this.name,
        length: this._attr.attribute_length
      };
    }
  }, {
    key: 'decoded',
    get: function get() {
      if (!this.hasDecoded) {
        if (!_.has(AttributeDecoderLookup, this._name)) {
          throw new Error('Attribute could not be decoded as it has no known decoder.');
        }

        this._decoded = AttributeDecoderLookup[this._name](this._owner);
      }

      return this._decoded;
    }

    /**
     * `true` if this attribute has been decoded
     * @return {Boolean}
     */

  }, {
    key: 'hasDecoded',
    get: function get() {
      return this._decoded !== false;
    }

    /**
     * Official name of the Attribute
     * @return {string}
     */

  }, {
    key: 'name',
    get: function get() {
      return this._name;
    }

    /**
     * Object parsed from JVM Class File.
     * @return {Object}
     */

  }, {
    key: 'raw',
    get: function get() {
      return this._attr;
    }

    /**
     * Raw Buffer of the Attribute from the JVM Class File.
     * @return {Buffer}
     */

  }, {
    key: 'rawData',
    get: function get() {
      return this._data;
    }
  }]);

  return AttributeInfo;
}();

exports.AttributeInfo = AttributeInfo;