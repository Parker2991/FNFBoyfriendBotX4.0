'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClassLoader = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('../util/lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _IoC = require('../ioc/IoC');

var _ClassInfo = require('./jvm/ClassInfo');

var _FieldInfo = require('./jvm/FieldInfo');

var _MethodInfo = require('./jvm/MethodInfo');

var _ConstantPool = require('./jvm/ConstantPool');

var _AttributeInfo = require('./jvm/AttributeInfo');

var _ClassCollection = require('./ClassCollection');

var _ClassFileParser = require('./parsers/ClassFileParser');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

_IoC.IoC.set('ClassInfoFactory', function (flags, version, name, superName, pool) {
  var cls = new _ClassInfo.ClassInfo(flags, version, name, superName, pool);
  return cls;
});

function constantPoolLookup(pool, poolIdx) {
  return _lodash2.default.get(pool, [poolIdx - 1, 'info', 'bytes']);
}

function replaceConstantPoolStringLookups(memberInfo, pool) {
  var lookups = ['name_index', 'descriptor_index', 'attribute_name_index'];

  _lodash2.default.intersection(lookups, _lodash2.default.keys(memberInfo)).forEach(function (lookup) {
    var parts = lookup.split('_');
    // This gives us all but the last "part" aka no _index suffix.
    var namePrefix = parts.splice(0, parts.length - 1).join('_');

    var poolIdx = memberInfo[lookup] - 1;
    var poolEntry = _lodash2.default.get(pool, [poolIdx, 'info', 'bytes']);
    // structure looks like: pool[poolIdx] = { tag: 1, info: { len: 10, bytes: 'SourceFile' }}

    memberInfo[namePrefix] = poolEntry;
  });

  // Fields and methods have nested attribute_info key-value-pairs which should have
  // their relevant strings pulled for them.
  _lodash2.default.each(_lodash2.default.intersection(['attribute_info'], _lodash2.default.keys(memberInfo)), function (key) {
    // We don't need to recurse if we're not going to find anything
    if (_lodash2.default.isEmpty(memberInfo[key])) {
      return;
    }

    memberInfo[key] = _lodash2.default.map(memberInfo[key], function (nestedMemberInfo) {
      return replaceConstantPoolStringLookups(nestedMemberInfo, pool);
    });
  });

  return memberInfo;
}

/**
 * Utility class for loading JVM Class Files into {@link ClassInfo} objects.
 */

var ClassLoader = function () {
  function ClassLoader() {
    _classCallCheck(this, ClassLoader);
  }

  _createClass(ClassLoader, [{
    key: 'loadClass',

    /**
     * Parses the class from the {@link Buffer} object.
     * @param  {string} name - the name of the Class File
     * @param  {Buffer} buff - the byte Buffer object
     * @return {Promise<ClassInfo>}
     */
    value: function loadClass(name, buff) {
      return new Promise(function (resolve, reject) {
        try {
          var cls = _ClassFileParser.ClassFileParser.parse(buff);

          ['fields', 'methods', 'attributes'].forEach(function (type) {
            if (_lodash2.default.has(cls, type)) {
              _lodash2.default.each(cls[type], function (info) {
                replaceConstantPoolStringLookups(info, cls.constant_pool);
              });
            }
          });

          var pool = cls.constant_pool;
          var version = { major: cls.major_version, minor: cls.minor_version };
          var className = constantPoolLookup(pool, pool[cls.this_class - 1].info.name_index);
          var superName = constantPoolLookup(pool, pool[cls.super_class - 1].info.name_index);
          var classInfo = _IoC.IoC.factory('ClassInfo')(cls.access_flags, version, className, superName, new _ConstantPool.ConstantPool(pool));

          _lodash2.default.each(cls.interfaces, function (intr) {
            var inter = constantPoolLookup(pool, pool[intr.class_index - 1].info.name_index);
            classInfo.addInterface(inter);
          });

          _lodash2.default.each(cls.methods, function (method) {
            var methodInfo = new _MethodInfo.MethodInfo(classInfo, method.access_flags, method.name, method.descriptor);
            method.attribute_info.forEach(function (attr) {
              methodInfo.addAttribute(new _AttributeInfo.AttributeInfo(attr, methodInfo));
            });
            classInfo.addMethod(methodInfo);
          });

          _lodash2.default.each(cls.fields, function (field) {
            var fieldInfo = new _FieldInfo.FieldInfo(classInfo, field.access_flags, field.name, field.descriptor);
            field.attribute_info.forEach(function (attr) {
              fieldInfo.addAttribute(new _AttributeInfo.AttributeInfo(attr, fieldInfo));
            });
            classInfo.addField(fieldInfo);
          });

          resolve(classInfo);
        } catch (err) {
          reject(err);
        }
      });
    }

    /**
     * Loads all classes from a {@link Jar}.
     * @param  {Jar} archive
     * @return {Promise<ClassCollection>}
     */

  }, {
    key: 'loadClasses',
    value: function loadClasses(archive) {
      var _this = this;

      var classes = new Map();
      return Promise.all(_lodash2.default.map(_lodash2.default.toMap(archive.classBuffers), function (buffer, name) {
        return _this.loadClass(name, buffer).then(function (cls) {
          classes.set(name, cls);
          return cls;
        });
      })).then(function () {
        return _ClassCollection.ClassCollection.of(classes);
      });
    }
  }]);

  return ClassLoader;
}();

exports.ClassLoader = ClassLoader;