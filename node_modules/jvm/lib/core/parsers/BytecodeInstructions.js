'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseInstructions = parseInstructions;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _NiceBuffer = require('./NiceBuffer');

var _Attributes = require('../jvm/Attributes');

var _instructions = require('../jvm/instructions');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function extractCodeFromMethod(method) {
  var code = method.findAttributeByName('Code');
  var attr = new _Attributes.JVMCodeAttribute(code.raw);

  return attr.decode().code;
}

/**
 * Parses the instructions from a given {@link MethodInfo}'s
 * {@link JVMCodeAttribute}.
 * @param  {MethodInfo} method
 * @return {Array<AbstractInstructions>}
 */
function parseInstructions(method) {
  var code = extractCodeFromMethod(method);
  var buffer = new _NiceBuffer.NiceBuffer(Buffer.from(code));

  var wide = false;
  var current = null;
  var instructions = [];
  while (buffer.pos < code.length) {
    var previous = current;
    var opcode = buffer.byte();
    var idx = instructions.length;

    current = _instructions.InstructionFactory.of(method, idx, opcode, wide);
    current.read(buffer);

    if (previous != null) {
      current.previous = previous;
      previous.next = current;
    }

    wide = opcode === _instructions.NAME_TO_OPCODE.WIDE;
    instructions.push(current);
  }

  return instructions;
}