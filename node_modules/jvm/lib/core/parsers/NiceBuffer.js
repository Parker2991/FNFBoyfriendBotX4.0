'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NiceBuffer = exports.SIZE_INT = exports.SIZE_SHORT = exports.SIZE_BYTE = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Number of bytes taken up by an 8bit Integer.
 * @type {Number}
 */
var SIZE_BYTE = exports.SIZE_BYTE = 1;

/**
 * Number of bytes taken up by a 16bit Integer.
 * @type {Number}
 */
var SIZE_SHORT = exports.SIZE_SHORT = 2;

/**
 * Number of bytes taken up by a 32bit Integer.
 * @type {Number}
 */
var SIZE_INT = exports.SIZE_INT = 4;

/**
 * Wraps Node's Buffer class by providing smart defaults specific
 * to the JVM's binary format.
 */

var NiceBuffer = exports.NiceBuffer = function () {
  /**
   * Instantiates a new instance
   *
   * @param  {Buffer} buffer normal Node Buffer object
   */
  function NiceBuffer(buffer) {
    _classCallCheck(this, NiceBuffer);

    /**
     * Current position in buffer.
     * @type {Number}
     */
    this.pos = 0;
    /**
     * @type {Buffer}
     */
    this.buffer = buffer;
    /**
     * Maps size constants to their respective method names.
     * @type {Object}
     */
    this.lengthMap = {};
    this.lengthMap[SIZE_INT] = 'int';
    this.lengthMap[SIZE_SHORT] = 'short';
    this.lengthMap[SIZE_BYTE] = 'byte';
  }

  /**
   * Moves the offset used when reading/writing bytes by a relative amount.
   * @param  {Number} len Relative offset to move
   * @return {Number}     The position before the offset is added to it.
   *                      Behavior is similar to `position++` rather than `++position`.
   */


  _createClass(NiceBuffer, [{
    key: 'move',
    value: function move(len) {
      var current = this.pos;
      this.pos += len;
      return current;
    }

    /**
     * Reads an arbitrary amount of bytes from the buffer.
     * If the length matches one of the `SIZE_` prefixed constants
     * also declared in this class, it will instead decode the bytes into
     * an unsigned integer of that size.
     * @param  {Number} len Number of bytes to read.
     * @return {Number|Buffer}
     */

  }, {
    key: 'read',
    value: function read(len) {
      if (!_.has(this.lengthMap, len)) {
        return this.slice(len);
      }

      var method = this.lengthMap[len];
      return this[method]();
    }
  }, {
    key: 'readStruct',
    value: function readStruct(struct) {
      var _this = this;

      var instance = {};

      _.each(struct, function (obj) {
        var _obj = _slicedToArray(obj, 2),
            name = _obj[0],
            value = _obj[1];

        if (name.startsWith('@')) {
          // need to for-loop it up
          var items = [];

          var _name$substring$split = name.substring(1).split('|'),
              _name$substring$split2 = _slicedToArray(_name$substring$split, 2),
              key = _name$substring$split2[0],
              lengthAttr = _name$substring$split2[1];

          var len = instance[lengthAttr];

          for (var idx = 0; idx < len; idx++) {
            items.push(_this.readStruct(value.struct));
          }

          instance[key] = items;
        } else if (name.startsWith('$')) {
          // read variable amount of bytes where the length has already
          // been stored in `instance`.
          var _key = name.substring(1);
          var _len = instance[value];
          instance[_key] = _this.slice(_len);
        } else {
          var length = value;
          instance[name] = _this.read(length);
        }
      });

      return instance;
    }

    /**
     * Reads an unsigned 16bit Integer from the buffer in Big Endian format.
     * @return {Number} ushort
     */

  }, {
    key: 'short',
    value: function short() {
      return this.buffer.readUInt16BE(this.move(SIZE_SHORT));
    }

    /**
     * Reads an unsigned 8bit Integer from the buffer.
     * @return {Number} ubyte
     */

  }, {
    key: 'byte',
    value: function byte() {
      return this.buffer.readUInt8(this.move(SIZE_BYTE));
    }

    /**
     * Reads an unsigned 32bit Integer from the buffer in Big Endian format.
     * @return {Number} uint
     */

  }, {
    key: 'int',
    value: function int() {
      return this.buffer.readUInt32BE(this.move(SIZE_INT));
    }

    /**
     * Writes an array of bytes to the current position in the buffer.
     * @param  {Array<Number>} bytes an array of bytes
     */

  }, {
    key: 'write',
    value: function write(bytes) {
      var _this2 = this;

      bytes.forEach(function (byte) {
        return _this2.writeByte(byte);
      });
    }

    /**
     * Writes a single ubyte to the current position in the buffer.
     * @param  {Number} val
     */

  }, {
    key: 'writeByte',
    value: function writeByte(val) {
      this.buffer.writeUInt8(val, this.move(SIZE_BYTE));
    }

    /**
     * Writes a ushort to the current position in the buffer in Big Endian format.
     * @param  {Number} val
     */

  }, {
    key: 'writeShort',
    value: function writeShort(val) {
      this.buffer.writeUInt16LE(val, this.move(SIZE_SHORT));
    }

    /**
     * Writes a uint to the current position in the buffer in Big Endian format.
     * @param  {Number} val
     */

  }, {
    key: 'writeInt',
    value: function writeInt(val) {
      this.buffer.writeUInt32LE(val, this.move(SIZE_INT));
    }

    /**
     * Slice a Buffer of bytes from the buffer of a specified length
     * at the current position.
     * @param  {Number} len Number of bytes to slice
     * @return {Buffer}
     */

  }, {
    key: 'slice',
    value: function slice(len) {
      var end = this.pos + len;
      return this.buffer.slice(this.move(len), end);
    }
  }]);

  return NiceBuffer;
}();